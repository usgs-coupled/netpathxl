  ! This software AUTODICE.F90 is part of the Compaq Visual Fortran kit.
  ! Copyright (C) 1997,1999 Digital Equipment Corporation.
  ! All rights reserved.
  ! 
  ! This software is furnished to you under a license by  Digital Equipment
  ! Corporation and must be used only in  accordance with the terms and conditions
  ! of that license,  and only with the inclusion of the above copyright notice.
  ! 
  ! This software is provided as an example that demonstrates a particular
  ! feature/function of the licensed product. The software is not intended to
  ! provide a complete solution to any application problem but rather is provided
  ! as a teaching mechanism.
  ! 
  ! Users may incorporate any part of this sample into their own source after 
  ! making appropriate changes to make it suitable for the intended application.

  ! This sample program takes 12 numbers and uses
  ! Automation to tell EXCEL 97 to draw a histogram of the numbers.
  ! The EXCEL97A module generated by the Fortran Module Wizard
  ! is used as the interface to EXCEL.  EXCEL97A supports the following EXCEL
  ! interfaces:
  !     _Application, _Chart, _Workbook, _Worksheet, Axes, Charts, Range,
  !     Workbooks, Worksheets
  !
  ! NOTES: 
  !     1.  Modify the file specification below if you have installed Visual
  !         Fortran in a directory other than 
  !         C:\PROGRAM FILES\MICROSOFT VISUAL STUDIO
  !     2.  After running this sample, if you save the changes to HISTO.XLS,
  !         you must re-copy the original version from the Visual Fortran 
  !         CD-ROM for this sample to work correctly.
  !

    Subroutine NewExcel

	  USE DFLIB
	  USE DFWIN
	  USE DFCOM
	  USE DFCOMTY
	  USE DFAUTO
	  USE ADOBJECTS
	  USE EXCEL97A
!	  USE EXCEL5EN32
      USE filenames
	  USE excel_headings
      IMPLICIT NONE   
	  integer lens
	  external lens                 
!	  CHARACTER*256 string

	! Variables
	  INTEGER*4 status
	  INTEGER*4 loopCount
	  INTEGER*4 die1
	  INTEGER*4 die2
	  INTEGER*4 roll
	  INTEGER*4 maxScale
	  CHARACTER (LEN = 32) :: loopc
	  INTEGER*4   i
      REAL*4    rnd
	  INTEGER*2, DIMENSION(1:12) :: cellCounts
	  integer*4 excelapp1

	  character*10 cell_location

	! Variant arguments
	  TYPE (VARIANT) :: vBSTR1
	  TYPE (VARIANT) :: vBSTR2
	  TYPE (VARIANT) :: vBSTR3
	  TYPE (VARIANT) :: vBSTR4
	  TYPE (VARIANT) :: vBSTR5

	  TYPE (VARIANT) :: vInt

	! Initialize object pointers
	  CALL INITOBJECTS()

	! Create an Excel object
	  CALL COMINITIALIZE(status)
      CALL COMCREATEOBJECT ("Excel.Application", excelapp, status)
 	  IF (excelapp == 0) THEN
		  WRITE (*, '(" Unable to create Excel object; Aborting")')
		  CALL EXIT()
	  END IF
      CALL $Application_SetVisible(excelapp, .FALSE.)

	! Here is a sketch of the code below in pseudocode...
	!
	!	workbooks = excelapp.GetWorkbooks()
	!	workbook = workbooks.Open(spreadsheet)
	!	worksheet = workbook.GetActiveSheet
	!	range = worksheet.GetRange("A1", "L1")
	!	range.Select()
	!	charts = workbook.GetCharts()
	!	chart = charts.Add()
	!	chart.ChartWizard(gallery=chartType, title=title, categoryTitle=title, valueTitle=title)
	!	valueAxis = chart.Axes(type=xlValue, axisGroup=xlPrimary)
	!   valueAxis.MaximumScale(loopcount/5)

	! Get the WORKBOOKS object
	  workbooks = $Application_GetWorkbooks(excelapp, $STATUS = status)
	  CALL Check_Status(status, " Unable to get WORKBOOKS object")

	! Open the specified spreadsheet file (note: specify the full file path)
	!  workbook = Workbooks_Open(workbooks, &
    !    "C:\PROGRAM FILES\MICROSOFT VISUAL STUDIO\DF98\SAMPLES\ADVANCED\COM\AUTODICE\HISTO.XLS", &
    !    $STATUS = status)
	  workbook = Workbooks_Add(workbooks,$STATUS = status )
	  CALL Check_Status(status, " Unable to get WORKBOOK object; ensure that the file path is correct")
 
	! Get the worksheet
	  vInt%VT = VT_I4
	  vInt%VU%LONG_VAL = 1
      worksheet = $Workbook_GetActiveSheet(workbook, status)
	  CALL Check_Status(status, " Unable to get WORKSHEET object")

	! Set header character strings
	  colheadings(2,5) = "Alk/" // Char(10) // "TDIC Flag"
	  do i = 1, 21
		call setcell_character(headings(1,i), headings(2,i))
	  enddo

	! Set column header character strings
	  do i = 1, count_colheadings
		call setcell_character(colheadings(1,i), colheadings(2,i))
	  enddo

	  ! Initialize well numbers
	  DO i=1,2
		write(cell_location,'("a",i1)') i+7
	  	call setcell_integer(cell_location, i)
	  END DO
	  DO i=3,50
		write(cell_location,'("a",i2)') i+7
	  	call setcell_integer(cell_location, i)
	  END DO

      ! set width for well name
	  call set_range('b1','b1')
	  CALL VariantInit(vBSTR1)
	  vBSTR1%VT = VT_R4
	  vBSTR1%VU%FLOAT_VAL = 30.
	  call range_setcolumnwidth(range, vBSTR1, status)
	  CALL Check_Status(status, " Unable to set column width")
	  status = VariantClear(vBSTR1)
	  bstr1 = 0

	  ! set width for flags
	  call set_range('c1','f1')
	  CALL VariantInit(vBSTR1)
	  vBSTR1%VT = VT_R4
	  vBSTR1%VU%FLOAT_VAL = 4.29
	  call range_setcolumnwidth(range, vBSTR1, status)
	  CALL Check_Status(status, " Unable to set column width")
	  status = VariantClear(vBSTR1)
	  bstr1 = 0

	       ! set width for well name
	  call set_range('be7','bi7')
	  CALL VariantInit(vBSTR1)
	  vBSTR1%VT = VT_R4
	  vBSTR1%VU%FLOAT_VAL = 20.
	  call range_setcolumnwidth(range, vBSTR1, status)
	  CALL Check_Status(status, " Unable to set column width")
	  status = VariantClear(vBSTR1)
	  bstr1 = 0

	  ! set wrap and center on row 7
	  call set_range('a7','bg7')
	  call set_variant_bool(vARG1, .true.)
      call range_SetWrapText(range, vARG1, status)
	  call set_variant_int(vARG1, -4108)
      call range_SetHorizontalAlignment(range, vARG1, status)
	  CALL Check_Status(status, " Unable to set horizontal alignment")

	  ! Set default protection false
	  range = $worksheet_getcells(worksheet, status)
      CALL Check_Status(status, " Unable to set range to all cells")
      call set_variant_bool(vARG1, .false.)
	  call range_setlocked(range, vARG1, status)
	  
	  !Set protection on Headers
	  call set_range('a1','au7')
	  call set_variant_bool(vARG1, .true.)
	  call range_setlocked(range, vARG1, status)


 
 	  !Set protection on worksheet
	  !call $worksheet_protect(worksheet)

	  !Save workbook
	  !string = path(1:lens(path)) // '\' // dfile(1:lens(dfile)) // '.xls'
	  !call set_variant_char(vARG1, string)
	  !call $workbook_saveas(workbook, vARG1)
	  !CALL Check_Status(status, " Unable to save workbook")


!    Cells.Select
!    Selection.Locked = False
!    Selection.FormulaHidden = False
!    Range("A1:AS7").Select
!    Range("A7").Activate
!    Selection.Locked = True
!    Selection.FormulaHidden = False
!    ActiveSheet.Protect DrawingObjects:=True, Contents:=True, Scenarios:=True _
!        , AllowFormattingCells:=True, AllowFormattingColumns:=True, _
!        AllowFormattingRows:=True, AllowInsertingRows:=True, AllowDeletingColumns _
!        :=True, AllowDeletingRows:=True, AllowSorting:=True


	! Release all objects
	!  CALL RELEASEOBJECTS()
	!  CALL COMUNINITIALIZE()

    END subroutine NewExcel
!
!
!
    Subroutine SaveExcel

	  USE DFLIB
	  USE DFWIN
	  USE DFCOM
	  USE DFCOMTY
	  USE DFAUTO
	  USE ADOBJECTS
	  USE EXCEL97A
!	  USE EXCEL5EN32
      USE filenames
      IMPLICIT NONE   	  !Save workbook
	  CHARACTER*256 string
	  integer lens
	  external lens       

	  string = path(1:lens(path)) // '\' // root(1:lens(root)) // '.xls'
	  call set_variant_char(vARG1, string)
	  call $workbook_saveas(workbook, vARG1)
	  !CALL Check_Status(status, " Unable to save workbook")!
	return
	end subroutine SaveExcel
!
!
!
    Subroutine OldExcel

	  USE DFLIB
	  USE DFWIN
	  USE DFCOM
	  USE DFCOMTY
	  USE DFAUTO
	  USE ADOBJECTS
	  USE EXCEL97A
!	  USE EXCEL5EN32
      USE filenames
      IMPLICIT NONE   
	  integer lens
	  external lens                 
	  CHARACTER*256 string

	! Variables
	  INTEGER*4 status
	  TYPE (VARIANT) :: vInt

	! Initialize object pointers
	  CALL INITOBJECTS()

	! Create an Excel object
	  CALL COMINITIALIZE(status)
      CALL COMCREATEOBJECT ("Excel.Application", excelapp, status)
 	  IF (excelapp == 0) THEN
		  WRITE (*, '(" Unable to create Excel object; Aborting")')
		  CALL EXIT()
	  END IF

      CALL $Application_SetVisible(excelapp, .FALSE.)

	! Get the WORKBOOKS object
	  workbooks = $Application_GetWorkbooks(excelapp, $STATUS = status)
	  CALL Check_Status(status, " Unable to get WORKBOOKS object")

	! Open the specified spreadsheet file (note: specify the full file path)
	filename = path(1:lens(path)) // '\' // root(1:lens(root)) // '.xls'
	workbook = Workbooks_Open(workbooks, &
        filename, &
        $STATUS = status)
!	  workbook = Workbooks_Add(workbooks,$STATUS = status )
	  CALL Check_Status(status, " Unable to get WORKBOOK object; ensure that the file path is correct")
 
	! Get the worksheet
	  vInt%VT = VT_I4
	  vInt%VU%LONG_VAL = 1
      worksheet = $Workbook_GetActiveSheet(workbook, status)
	  CALL Check_Status(status, " Unable to get WORKSHEET object")

    END subroutine OldExcel
!
!
!
    logical function CheckOldExcel

	  USE DFLIB
	  USE DFWIN
	  USE DFCOM
	  USE DFCOMTY
	  USE DFAUTO
	  USE ADOBJECTS
	  USE EXCEL97A
!	  USE EXCEL5EN32
      USE filenames
	  USE excel_headings
      IMPLICIT NONE   
	  integer lens
	  external lens                 
	  CHARACTER*256 string

	! Variables
	  INTEGER*4 status
	  INTEGER*4 loopCount
	  INTEGER*4 die1
	  INTEGER*4 die2
	  INTEGER*4 roll
	  INTEGER*4 maxScale
	  logical npxlfile
	  INTEGER*4   i
      REAL*4    rnd
	  INTEGER*2, DIMENSION(1:12) :: cellCounts
	  integer*4 excelapp1
	
	  character*10 cell_location

	! Variant arguments
	  TYPE (VARIANT) :: vBSTR1
	  TYPE (VARIANT) :: vBSTR2
	  TYPE (VARIANT) :: vBSTR3
	  TYPE (VARIANT) :: vBSTR4
	  TYPE (VARIANT) :: vBSTR5

	  TYPE (VARIANT) :: vInt


 
	  colheadings(2,5) = "Alk/" // Char(10) // "TDIC Flag"
	! Check cell a1
	 npxlfile = .true.
	 do i = 1, 1
		call set_range(headings(1,1),headings(1,1))
		status = AUTOGETPROPERTY (range, "VALUE", string)
		CALL Check_Status(status, "Read cell")
		!if (string(1:lens(string)) .ne. headings(2,1)(1:lens(headings(2,1)))) then
		if (string .ne. headings(2,1)) then
			npxlfile = .false.
			exit
		endif
	  enddo

	! Set column header character strings
	  do i = 1, count_colheadings
		call set_range(colheadings(1,i),colheadings(1,i))
		status = AUTOGETPROPERTY (range, "VALUE", string)
		CALL Check_Status(status, "Read cell")
		if (string .ne. colheadings(2,i)) then
			npxlfile = .false.
			exit
		endif
		if (colheadings(1,i) == 'au7') then
			exit
		endif
	  enddo

	CheckOldExcel = npxlfile
    if (npxlfile) then
		CALL $Application_SetVisible(excelapp, .TRUE.)
	else
		CALL $Application_quit(excelapp, status)
		CALL Check_Status(status, "Quit Excel on incorrect file.")
	endif
    END function CheckOldExcel
!
!
!
	SUBROUTINE cleanup_com
	  USE ADOBJECTS
	! Release all objects
	  CALL RELEASEOBJECTS()
	  CALL COMUNINITIALIZE()
	END subroutine cleanup_com

	SUBROUTINE Check_Status(olestatus, errorMsg)
	  USE ADOBJECTS
      IMPLICIT NONE                       

	  INTEGER*4 olestatus
	  CHARACTER (LEN = *) :: errorMsg

	  IF (olestatus >= 0) THEN
		  RETURN
	  END IF

	! Error handling code
	  CALL RELEASEOBJECTS()
	  WRITE (*, '(A, "; OLE error status = 0x", Z8.8, "; Aborting")') TRIM(errorMsg), olestatus
	  CALL SLEEPQQ(5000)
	  CALL EXIT(-1)

    END SUBROUTINE
	!
!
!
SUBROUTINE DB2XL
  use filenames
  USE ADOBJECTS
  IMPLICIT NONE
  CHARACTER*16 words(45)
  CHARACTER*1 UPCS, ans
  CHARACTER*80 line
  CHARACTER*20 frmt
  CHARACTER*10 piece
  CHARACTER*80 funame, char_linenum, cell_location
  INTEGER LENS, n, i, jcounter, k, j, kk, linenum
  !
  REAL Dbdata
  COMMON /DB    / Dbdata(50,45)
  INTEGER Dbsfg, Idefault, Iu, Nwlls, Totwell, Tot
  COMMON /INT4  / Dbsfg(50,45), Idefault(5), Iu(50,4), Nwlls,  &
       Totwell, Tot(50)
  CHARACTER Wllnms*80, Address*40, Lat*40, Formation*17
  COMMON /CHAR1 / Wllnms(50), Address(50,5), Lat(50), Formation(50)
  INTEGER Icase, Iw1, Iw2, Ir, Iex1, Io1, Iscr2
  COMMON /FUNITS/ Icase, Iw1, Iw2, Ir, Iex1, Io1, Iscr2

  !
  EXTERNAL LENS, UPCS
  INTRINSIC CHAR, ICHAR
  !
  DATA words/'Temperature     ', 'pH              ',  &
       'Dissolved Oxygen', 'Alkalinity      ', 'Tritium         ',  &
       'H2S as S        ', 'Calcium         ', 'Eh              ',  &
       'Magnesium       ', 'Sodium          ', 'Potassium       ',  &
       'Chloride        ', 'Sulfate         ', 'Fluoride        ',  &
       'Silica          ', 'Bromide         ', 'Boron           ',  &
       'Barium          ', 'Lithium         ', 'Strontium       ',  &
       'Iron            ', 'Manganese       ', 'Nitrate         ',  &
       'Ammonium        ', 'Phosphate       ', 'DOC             ',  &
       'Sp. Cond.       ', 'Density         ', 'Delta C-13 TDIC ',  &
       'Carbon 14 TDIC  ', 'Delta S-34 (SO4)', 'Delta S-34 (H2S)',  &
       'Delta Deuterium ', 'Delta O-18      ', 'CH4 (aq)        ',  &
       'Sr 87/86        ', 'Aluminum        ', 'N2 (aq)         ',  &
       'N-15 of N2 (aq) ', 'N-15 of Nitrate ', 'N-15 of Ammonium',  &
       'Depth           ', 'Casing          ', 'Elevation       ',  &
       'RS of DOC       '/
  character*2 location(45)
  data location/' G', ' H', &
		'AD', ' P', 'AO', &
		'AE', ' J', ' I', &
		' K', ' L', ' M', &
		' N', ' O', ' T', &
		' U', ' V', ' W', &
		' X', ' Y', ' Z', &
		' Q', ' R', 'AA', &
		'AB', 'AC', 'AH', &
		'AV', 'AU', 'AJ', &
		'AK', 'AL', 'AM', &
		'AN', 'AP', 'AG', &
		'AQ', ' S', 'AF', &
		'AR', 'AS', 'AT', &
		'BB', 'BC', 'BD', &
		'AI'/
  !
  WRITE (*,*) 'Translating .lon to Excel ...'
  funame = root(1:LENS(root))//'.lon'
70 CONTINUE
  !
  !   Open file
  !
!  OPEN (Iw1,FILE=funame)
!  WRITE (Iw1,'(A,T60,"# File format")',ERR=50) "2.14"
  !
  !   Save each well
  ! 
  linenum = 8
  DO n = 1, Nwlls
	write(char_linenum,'(i2)') linenum
	if (char_linenum(1:1) == ' ') then
		char_linenum = char_linenum(2:2)
	endif
     !   write(cell_location,'("a",i1)') i+7
     !       Wellnms
     ! WRITE (Iw1,9005,ERR=50) Iu(n,1), Iu(n,2), Iu(n,3), Iu(n,4),  &
     !     Wllnms(n)(5:80)
!9005 FORMAT (4(I1),A76)
     cell_location = "B" // char_linenum
	 call setcell_character(cell_location, wllnms(n)(5:80))
     cell_location = "C" // char_linenum
	 call setcell_integer(cell_location, iu(n,1))
     cell_location = "D" // char_linenum
	 call setcell_integer(cell_location, iu(n,2))
     cell_location = "E" // char_linenum
	 call setcell_integer(cell_location, iu(n,3))
     cell_location = "F" // char_linenum
	 call setcell_integer(cell_location, iu(n,4))
     !       Lat/lon
     !WRITE (Iw1,'(a40,T60,"# Lat/lon")') Lat(n)
	 cell_location = "AZ" // char_linenum
	 call setcell_character(cell_location, lat(n))
     !       Well num
     !WRITE (Iw1,'(I15,T60,"# Well number")') Tot(n)
     cell_location = "A" // char_linenum
	 call setcell_integer(cell_location, tot(n))
     !       Total number of wells
     !WRITE (Iw1,'(I15,T60,"# Total wells")') Totwell
     !DO i = 1, 5
        !       Address
        !WRITE (Iw1,'(A,T60,"# Address",I1)') Address(n,i), i
     !enddo		
	 cell_location = "BE" // char_linenum
	 call setcell_character(cell_location, address(n,1))
	 cell_location = "BF" // char_linenum
	 call setcell_character(cell_location, address(n,2))
	 cell_location = "BG" // char_linenum
	 call setcell_character(cell_location, address(n,3))
	 cell_location = "BH" // char_linenum
	 call setcell_character(cell_location, address(n,4))
	 cell_location = "BI" // char_linenum
	 call setcell_character(cell_location, address(n,5))
     jcounter = 41
     !do j = 1, jcounter 
     !   IF (Dbsfg(n,j).GE.0) THEN
     !      frmt = '(F15.'//CHAR(ICHAR('0')+Dbsfg(n,j))// &
     !           ',T60,"# ",A)'
     !      WRITE(Iw1,frmt) Dbdata(n,j), words(j)
     !   ELSE IF (Dbsfg(n,j).EQ.-2) THEN
     !      WRITE(Iw1,'("<",F14.3,T60,"# ",A)') Dbdata(n,j), words(j)
     !   ELSE
     !      WRITE(Iw1,'("               ",T60,"# ",A)') words(j)
     !   END IF
     !enddo     ! 1 well
	 do j = 1, 45
		cell_location = location(j) // char_linenum
		call setcell_float(cell_location, dbdata(n,j))
	 enddo
     !WRITE (Iw1,'(A,T60,"# Formation")') Formation(n)
	 linenum = linenum + 1
  enddo       ! all wells
 ! close (Iw1)
  return
50 CONTINUE
  !
  !     Error writing to file, probably write protected
  !
  WRITE (*,9030) funame
80 WRITE (*,9040)
  READ (*,9000,ERR=80) ans
  call moverelative(-2)
  call clpart 
  IF (UPCS(ans).EQ.'Y') THEN
     CLOSE (Iw1, STATUS='DELETE')
     GOTO 70
  ELSE IF (UPCS(ans).NE.'N') THEN
     GOTO 80
  END IF
  !
  RETURN
9000 FORMAT (A)
9010 FORMAT (A40,24X,'#',I5,' of ',I5)
9015 FORMAT ('<',F9.3)
9020 FORMAT (A17)
9030 FORMAT ('WARNING: Error writing to file: ',A40/ &
       'File may be write protected.'/)
9040 FORMAT ('Do you want to OVERWRITE the file (y or n)?')
END SUBROUTINE db2xl
