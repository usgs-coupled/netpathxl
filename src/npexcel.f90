  ! This software AUTODICE.F90 is part of the Compaq Visual Fortran kit.
  ! Copyright (C) 1997,1999 Digital Equipment Corporation.
  ! All rights reserved.
  ! 
  ! This software is furnished to you under a license by  Digital Equipment
  ! Corporation and must be used only in  accordance with the terms and conditions
  ! of that license,  and only with the inclusion of the above copyright notice.
  ! 
  ! This software is provided as an example that demonstrates a particular
  ! feature/function of the licensed product. The software is not intended to
  ! provide a complete solution to any application problem but rather is provided
  ! as a teaching mechanism.
  ! 
  ! Users may incorporate any part of this sample into their own source after 
  ! making appropriate changes to make it suitable for the intended application.

  ! This sample program takes 12 numbers and uses
  ! Automation to tell EXCEL 97 to draw a histogram of the numbers.
  ! The EXCEL97A module generated by the Fortran Module Wizard
  ! is used as the interface to EXCEL.  EXCEL97A supports the following EXCEL
  ! interfaces:
  !     _Application, _Chart, _Workbook, _Worksheet, Axes, Charts, Range,
  !     Workbooks, Worksheets
  !
  ! NOTES: 
  !     1.  Modify the file specification below if you have installed Visual
  !         Fortran in a directory other than 
  !         C:\PROGRAM FILES\MICROSOFT VISUAL STUDIO
  !     2.  After running this sample, if you save the changes to HISTO.XLS,
  !         you must re-copy the original version from the Visual Fortran 
  !         CD-ROM for this sample to work correctly.
  !

	Subroutine NewExcel
      USE max_size
	  USE IFCOM
	  USE ADOBJECTS
	  USE excel_headings
	  
	  IMPLICIT NONE   
	  integer lens
	  external lens                 

	! Variables
	  INTEGER*4 status
	  TYPE (VARIANT) :: template
	  INTEGER*4 loopCount
	  INTEGER*4 die1
	  INTEGER*4 die2
	  INTEGER*4 roll
	  INTEGER*4 maxScale
	  CHARACTER (LEN = 32) :: loopc
	  INTEGER*4   i, j
	  LOGICAL*2 l
	  REAL*4    rnd
	  INTEGER*2, DIMENSION(1:12) :: cellCounts
	  integer*4 excelapp1

	  character*10 cell_location

	! Variant arguments
	  TYPE (VARIANT) :: vBSTR1
	  TYPE (VARIANT) :: vBSTR2
	  TYPE (VARIANT) :: vBSTR3
	  TYPE (VARIANT) :: vBSTR4
	  TYPE (VARIANT) :: vBSTR5

	  TYPE (VARIANT) :: vInt

	! Initialize object pointers
	  CALL INITOBJECTS()

	! Create an Excel object
	  CALL COMINITIALIZE(status)
	  CALL COMCreateObjectByProgID("Excel.Application", excelapp, status)
!      CALL COMCREATEOBJECT ("Excel.Application", excelapp, status)
	  IF (excelapp == 0) THEN
		  WRITE (*, '(" Unable to create Excel object; Aborting")')
		  CALL EXIT()
	  END IF
	  l = .FALSE.
	  CALL $Application_SetVisible(excelapp, l)

	! Here is a sketch of the code below in pseudocode...
	!
	!	workbooks = excelapp.GetWorkbooks()
	!	workbook = workbooks.Open(spreadsheet)
	!	worksheet = workbook.GetActiveSheet
	!	range = worksheet.GetRange("A1", "L1")
	!	range.Select()
	!	charts = workbook.GetCharts()
	!	chart = charts.Add()
	!	chart.ChartWizard(gallery=chartType, title=title, categoryTitle=title, valueTitle=title)
	!	valueAxis = chart.Axes(type=xlValue, axisGroup=xlPrimary)
	!   valueAxis.MaximumScale(loopcount/5)

	! Get the WORKBOOKS object
	  workbooks = $Application_GetWorkbooks(excelapp, status)
	  CALL Check_Status(status, " Unable to get WORKBOOKS object")

	! Open the specified spreadsheet file (note: specify the full file path)
	!  workbook = Workbooks_Open(workbooks, &
	!    "C:\PROGRAM FILES\MICROSOFT VISUAL STUDIO\DF98\SAMPLES\ADVANCED\COM\AUTODICE\HISTO.XLS", &
	!    $STATUS = status)
	  workbook = Workbooks_Add(workbooks,$STATUS = status )
	  CALL Check_Status(status, " Unable to get WORKBOOK object; ensure that the file path is correct")
 
	! Get the worksheet
	  vInt%VT = VT_I4
	  vInt%VU%LONG_VAL = 1
	  worksheet = $Workbook_GetActiveSheet(workbook, status)
	  CALL Check_Status(status, " Unable to get WORKSHEET object")

	! Set header character strings
	  colheadings(2,5) = "Alk/" // Char(10) // "TDIC Flag"
	  do i = 1, 21
		call setcell_character(headings(1,i), headings(2,i))
	  enddo

	! Set column header character strings
	  do i = 1, count_colheadings
		call setcell_character(colheadings(1,i), colheadings(2,i))
	  enddo

	  ! Initialize well numbers
!	  DO i=1,2
!		write(cell_location,'("a",i1)') i+7
!		call setcell_integer(cell_location, i)
!	  END DO
!	  DO i=3,50
!		write(cell_location,'("a",i2)') i+7
!		call setcell_integer(cell_location, i)
!	  END DO
	  DO i=1, MAXWELLS
	  
		write(cell_location,'(i5)') i+7
		do j = 1, 4
		    if (cell_location(1:1) .eq. ' ') then
		        cell_location = cell_location(2:5)
		    endif
		enddo
		cell_location = 'a'//cell_location
		call setcell_integer(cell_location, i)
	  END DO

	  ! set width for well name
	  call set_range('b1','b1')
	  CALL VariantInit(vBSTR1)
	  vBSTR1%VT = VT_R4
	  vBSTR1%VU%FLOAT_VAL = 30.
	  call range_setcolumnwidth(range, vBSTR1, status)
	  CALL Check_Status(status, " Unable to set column width")
	  status = VariantClear(vBSTR1)
	  bstr1 = 0

	  ! set width for flags
	  call set_range('c1','f1')
	  CALL VariantInit(vBSTR1)
	  vBSTR1%VT = VT_R4
	  vBSTR1%VU%FLOAT_VAL = 4.29
	  call range_setcolumnwidth(range, vBSTR1, status)
	  CALL Check_Status(status, " Unable to set column width")
	  status = VariantClear(vBSTR1)
	  bstr1 = 0

		   ! set width for well name
	  call set_range('be7','bi7')
	  CALL VariantInit(vBSTR1)
	  vBSTR1%VT = VT_R4
	  vBSTR1%VU%FLOAT_VAL = 20.
	  call range_setcolumnwidth(range, vBSTR1, status)
	  CALL Check_Status(status, " Unable to set column width")
	  status = VariantClear(vBSTR1)
	  bstr1 = 0

	  ! set wrap and center on row 7
	  call set_range('a7','bg7')
	  call set_variant_bool(vARG1, .true.)
	  call range_SetWrapText(range, vARG1, status)
	  call set_variant_int(vARG1, -4108)
	  call range_SetHorizontalAlignment(range, vARG1, status)
	  CALL Check_Status(status, " Unable to set horizontal alignment")

	  ! Set default protection false
	  range = $worksheet_getcells(worksheet, status)
	  CALL Check_Status(status, " Unable to set range to all cells")
	  call set_variant_bool(vARG1, .false.)
	  call range_setlocked(range, vARG1, status)
	  !Set protection on Headers
	  call set_range('a1','au7')
	  call set_variant_bool(vARG1, .true.)
	  call range_setlocked(range, vARG1, status)
 
	  !Set protection on worksheet
	  call $worksheet_protect(worksheet)

	  !Save workbook
	  !string = path(1:lens(path)) // '\' // dfile(1:lens(dfile)) // '.xls'
	  !call set_variant_char(vARG1, string)
	  !call $workbook_saveas(workbook, vARG1)
	  !CALL Check_Status(status, " Unable to save workbook")


!    Cells.Select
!    Selection.Locked = False
!    Selection.FormulaHidden = False
!    Range("A1:AS7").Select
!    Range("A7").Activate
!    Selection.Locked = True
!    Selection.FormulaHidden = False
!    ActiveSheet.Protect DrawingObjects:=True, Contents:=True, Scenarios:=True _
!        , AllowFormattingCells:=True, AllowFormattingColumns:=True, _
!        AllowFormattingRows:=True, AllowInsertingRows:=True, AllowDeletingColumns _
!        :=True, AllowDeletingRows:=True, AllowSorting:=True


	! Release all objects
	!  CALL RELEASEOBJECTS()
	!  CALL COMUNINITIALIZE()

	END subroutine NewExcel
!
!
!
	Subroutine SaveExcel

	  USE ADOBJECTS
	  USE filenames
	  
	  IMPLICIT NONE   	  !Save workbook
	  CHARACTER*256 string
	  integer lens
	  integer*4 status
	  external lens   
	  
	  string = path(1:lens(path)) // '\' // root(1:lens(root)) // '.xls'
	  call set_variant_char(vARG1, string)
	  call set_variant_char(vARG2, '')
	  call $workbook_saveas(workbook, vARG1)
	  CALL Check_Status(status, " Unable to save workbook")!
	return
	end subroutine SaveExcel
!
!
!
Subroutine OldExcel

	USE ADOBJECTS
	use filenames
	
	IMPLICIT NONE   
	  integer lens
	  external lens                 
	  CHARACTER*256 string

	! Variables
	  INTEGER*4 status
	  logical*2 l
	  TYPE (VARIANT) :: vInt


	! Initialize object pointers
	  CALL INITOBJECTS()

	! Create an Excel object
	  CALL COMINITIALIZE(status)
	  CALL COMCreateObjectByProgID("Excel.Application", excelapp, status)
!      CALL COMCREATEOBJECT ("Excel.Application", excelapp, status)
	  IF (excelapp == 0) THEN
		  WRITE (*, '(" Unable to create Excel object; Aborting")')
		  CALL EXIT()
	  END IF
	  CALL Check_Status(status, " Unable to create Excel application")
	  
	  l = .FALSE.
	  CALL $Application_SetVisible(excelapp, l)

	! Get the WORKBOOKS object
	  workbooks = $Application_GetWorkbooks(excelapp, status)
	  CALL Check_Status(status, " Unable to get WORKBOOKS object")

	! Open the specified spreadsheet file (note: specify the full file path)
	filename = path(1:lens(path)) // '\' // root(1:lens(root)) // '.xls'
	workbook = Workbooks_Open(workbooks, &
		filename, &
		$STATUS = status)

	  CALL Check_Status(status, " Unable to get WORKBOOK object; ensure that the file path is correct")
 
	! Get the worksheet
	  vInt%VT = VT_I4
	  vInt%VU%LONG_VAL = 1
	  worksheet = $Workbook_GetActiveSheet(workbook, status)
	  CALL Check_Status(status, " Unable to get WORKSHEET object")

	END subroutine OldExcel
!
!
!
	logical function CheckOldExcel

	  USE ADOBJECTS
	  USE excel_headings
	  
	  IMPLICIT NONE   
	  integer lens
	  external lens                 
	  CHARACTER*256 string

	! Variables
	  INTEGER*4 status
	  INTEGER*4 loopCount
	  INTEGER*4 die1
	  INTEGER*4 die2
	  INTEGER*4 roll
	  INTEGER*4 maxScale
	  logical npxlfile
	  INTEGER*4   i
	  REAL*4    rnd
	  INTEGER*2, DIMENSION(1:12) :: cellCounts
	  integer*4 excelapp1
	
	  character*10 cell_location

	! Variant arguments
	  TYPE (VARIANT) :: vBSTR1
	  TYPE (VARIANT) :: vBSTR2
	  TYPE (VARIANT) :: vBSTR3
	  TYPE (VARIANT) :: vBSTR4
	  TYPE (VARIANT) :: vBSTR5

	  TYPE (VARIANT) :: vInt


 
	  colheadings(2,5) = "Alk/" // Char(10) // "TDIC Flag"
	! Check cell a1
	 npxlfile = .true.
	 do i = 1, 1
		call set_range(headings(1,1),headings(1,1))
		status = AUTOGETPROPERTY (range, "VALUE", string)
		CALL Check_Status(status, "Read cell")
		if (string .ne. headings(2,1)) then
			npxlfile = .false.
			exit
		endif
	  enddo

	! Set column header character strings
	  do i = 1, count_colheadings
		call set_range(colheadings(1,i),colheadings(1,i))
		status = AUTOGETPROPERTY (range, "VALUE", string)
		CALL Check_Status(status, "Read cell")
		if (string .ne. colheadings(2,i)(1:lens(string))) then
			npxlfile = .false.
			exit
		endif
		if (colheadings(1,i) == 'au7') then
			exit
		endif
	  enddo

	CheckOldExcel = npxlfile
	if (npxlfile) then
!		CALL $Application_SetVisible(excelapp, .TRUE.)
	else
		CALL $Application_quit(excelapp, status)
		CALL Check_Status(status, "Quit Excel on incorrect file.")
	endif
	END function CheckOldExcel
!
!
!
	subroutine VisibleExcel(switch) 
	  USE ADOBJECTS

	  IMPLICIT NONE   
		  
	  CHARACTER*256 string

	! Variables
	  logical switch
	  integer*4 status
	  logical*2 l
	  
	  l = switch

	CALL $Application_SetVisible(excelapp, l)

	END subroutine VisibleExcel 
!
!
!
SUBROUTINE cleanup_com(terminate)

	USE ADOBJECTS

	INTEGER*4 status
	logical terminate

	if (terminate) then
		CALL $Application_Quit(excelapp, status)
		CALL Check_Status(status, "Quit Excel failed.")
	endif
	! Release all objects
	CALL RELEASEOBJECTS()
	CALL COMUNINITIALIZE()
	RETURN
END subroutine cleanup_com

	SUBROUTINE Check_Status(olestatus, errorMsg)
	  USE ADOBJECTS
	  IMPLICIT NONE                       

	  INTEGER*4 olestatus
	  CHARACTER (LEN = *) :: errorMsg

	  IF (olestatus >= 0) THEN
		  RETURN
	  END IF

	! Error handling code

	  WRITE (*, '(A, "; OLE error status = 0x", Z8.8, "; Aborting")') TRIM(errorMsg), olestatus
	  CALL SLEEPQQ(5000)
	  
	  CALL RELEASEOBJECTS()
	  CALL EXIT(-1)

	END SUBROUTINE
	!
!
!
SUBROUTINE DB2XL
  USE max_size
  use filenames
  USE ADOBJECTS
  IMPLICIT NONE
  CHARACTER*16 words(45)
  CHARACTER*1 UPCS, ans
  CHARACTER*80 line
  CHARACTER*20 frmt
  CHARACTER*10 piece
  CHARACTER*80 funame, char_linenum, cell_location
  INTEGER LENS, n, i, jcounter, k, j, kk, linenum
  !
  REAL Dbdata
  COMMON /DB    / Dbdata(MAXWELLS,45)
  INTEGER Dbsfg, Idefault, Iu, Nwlls, Totwell, Tot
  COMMON /INT4DB/ Dbsfg(MAXWELLS,45), Idefault(5), Iu(MAXWELLS,4), Nwlls,  &
	   Totwell, Tot(MAXWELLS)
  CHARACTER Wllnms*80, Address*40, Lat*40, Formation*17
  COMMON /CHAR1 / Wllnms(MAXWELLS), Address(MAXWELLS,5), Lat(MAXWELLS), Formation(MAXWELLS)
  INTEGER Icase, Iw1, Iw2, Ir, Iex1, Io1, Iscr2
  COMMON /FUNITS/ Icase, Iw1, Iw2, Ir, Iex1, Io1, Iscr2

  !
  EXTERNAL LENS, UPCS
  INTRINSIC CHAR, ICHAR
  !
  DATA words/'Temperature     ', 'pH              ',  &
	   'Dissolved Oxygen', 'Alkalinity      ', 'Tritium         ',  &
	   'H2S as S        ', 'Calcium         ', 'Eh              ',  &
	   'Magnesium       ', 'Sodium          ', 'Potassium       ',  &
	   'Chloride        ', 'Sulfate         ', 'Fluoride        ',  &
	   'Silica          ', 'Bromide         ', 'Boron           ',  &
	   'Barium          ', 'Lithium         ', 'Strontium       ',  &
	   'Iron            ', 'Manganese       ', 'Nitrate         ',  &
	   'Ammonium        ', 'Phosphate       ', 'DOC             ',  &
	   'Sp. Cond.       ', 'Density         ', 'Delta C-13 TDIC ',  &
	   'Carbon 14 TDIC  ', 'Delta S-34 (SO4)', 'Delta S-34 (H2S)',  &
	   'Delta Deuterium ', 'Delta O-18      ', 'CH4 (aq)        ',  &
	   'Sr 87/86        ', 'Aluminum        ', 'N2 (aq)         ',  &
	   'N-15 of N2 (aq) ', 'N-15 of Nitrate ', 'N-15 of Ammonium',  &
	   'Depth           ', 'Casing          ', 'Elevation       ',  &
	   'RS of DOC       '/
  character*2 location(45)
  data location/' G', ' H', &
		'AD', ' P', 'AO', &
		'AE', ' J', ' I', &
		' K', ' L', ' M', &
		' N', ' O', ' T', &
		' U', ' V', ' W', &
		' X', ' Y', ' Z', &
		' Q', ' R', 'AA', &
		'AB', 'AC', 'AH', &
		'AV', 'AU', 'AJ', &
		'AK', 'AL', 'AM', &
		'AN', 'AP', 'AG', &
		'AQ', ' S', 'AF', &
		'AR', 'AS', 'AT', &
		'BB', 'BC', 'BD', &
		'AI'/
  !
  WRITE (*,*) 'Translating .lon to Excel ...'
  funame = root(1:LENS(root))//'.lon'
70 CONTINUE
  !
  !   Open file
  !
!  OPEN (Iw1,FILE=funame)
!  WRITE (Iw1,'(A,T60,"# File format")',ERR=50) "2.14"
  !
  !   Save each well
  ! 
  linenum = 8
  DO n = 1, Nwlls
	write(char_linenum,'(i2)') linenum
	if (char_linenum(1:1) == ' ') then
		char_linenum = char_linenum(2:2)
	endif
	 !   write(cell_location,'("a",i1)') i+7
	 !       Wellnms
	 ! WRITE (Iw1,9005,ERR=50) Iu(n,1), Iu(n,2), Iu(n,3), Iu(n,4),  &
	 !     Wllnms(n)(5:80)
!9005 FORMAT (4(I1),A76)
	 cell_location = "B" // char_linenum
	 call setcell_character(cell_location, wllnms(n)(5:80))
	 cell_location = "C" // char_linenum
	 call setcell_integer(cell_location, iu(n,1))
	 cell_location = "D" // char_linenum
	 call setcell_integer(cell_location, iu(n,2))
	 cell_location = "E" // char_linenum
	 call setcell_integer(cell_location, iu(n,3))
	 cell_location = "F" // char_linenum
	 call setcell_integer(cell_location, iu(n,4))
	 !       Lat/lon
	 !WRITE (Iw1,'(a40,T60,"# Lat/lon")') Lat(n)
	 cell_location = "AZ" // char_linenum
	 call setcell_character(cell_location, lat(n))
	 !       Well num
	 !WRITE (Iw1,'(I15,T60,"# Well number")') Tot(n)
	 cell_location = "A" // char_linenum
	 call setcell_integer(cell_location, tot(n))
	 !       Total number of wells
	 !WRITE (Iw1,'(I15,T60,"# Total wells")') Totwell
	 !DO i = 1, 5
		!       Address
		!WRITE (Iw1,'(A,T60,"# Address",I1)') Address(n,i), i
	 !enddo		
	 cell_location = "BE" // char_linenum
	 call setcell_character(cell_location, address(n,1))
	 cell_location = "BF" // char_linenum
	 call setcell_character(cell_location, address(n,2))
	 cell_location = "BG" // char_linenum
	 call setcell_character(cell_location, address(n,3))
	 cell_location = "BH" // char_linenum
	 call setcell_character(cell_location, address(n,4))
	 cell_location = "BI" // char_linenum
	 call setcell_character(cell_location, address(n,5))
	 jcounter = 41
	 !do j = 1, jcounter 
	 !   IF (Dbsfg(n,j).GE.0) THEN
	 !      frmt = '(F15.'//CHAR(ICHAR('0')+Dbsfg(n,j))// &
	 !           ',T60,"# ",A)'
	 !      WRITE(Iw1,frmt) Dbdata(n,j), words(j)
	 !   ELSE IF (Dbsfg(n,j).EQ.-2) THEN
	 !      WRITE(Iw1,'("<",F14.3,T60,"# ",A)') Dbdata(n,j), words(j)
	 !   ELSE
	 !      WRITE(Iw1,'("               ",T60,"# ",A)') words(j)
	 !   END IF
	 !enddo     ! 1 well
	 do j = 1, 45
		cell_location = location(j) // char_linenum
		call setcell_float(cell_location, dbdata(n,j), dbsfg(n,j))
	 enddo
	 !WRITE (Iw1,'(A,T60,"# Formation")') Formation(n)
	 linenum = linenum + 1
  enddo       ! all wells
 ! close (Iw1)
  return
50 CONTINUE
  !
  !     Error writing to file, probably write protected
  !
  WRITE (*,9030) funame
80 WRITE (*,9040)
  READ (*,9000,ERR=80) ans
  call moverelative(-2)
  call clpart 
  IF (UPCS(ans).EQ.'Y') THEN
	 CLOSE (Iw1, STATUS='DELETE')
	 GOTO 70
  ELSE IF (UPCS(ans).NE.'N') THEN
	 GOTO 80
  END IF
  !
  RETURN
9000 FORMAT (A)
9010 FORMAT (A40,24X,'#',I5,' of ',I5)
9015 FORMAT ('<',F9.3)
9020 FORMAT (A17)
9030 FORMAT ('WARNING: Error writing to file: ',A40/ &
	   'File may be write protected.'/)
9040 FORMAT ('Do you want to OVERWRITE the file (y or n)?')
END SUBROUTINE db2xl
!
!
!
SUBROUTINE XL2DB
    USE max_size
    USE ADOBJECTS
    use oleaut32
    use ifcom

    IMPLICIT NONE
    INTEGER*4 status
    character*256 string
    character*256 strings(4)
    CHARACTER*16 words(45)
    CHARACTER*1 UPCS, ans
    CHARACTER*80 line
    CHARACTER*20 frmt
    CHARACTER*10 piece
    CHARACTER*80 funame, char_linenum, cell_location
    INTEGER LENS, n, i, jcounter, k, j, kk, linenum
    !
    REAL Dbdata
    COMMON /DB    / Dbdata(MAXWELLS,45)
    INTEGER Dbsfg, Idefault, Iu, Nwlls, Totwell, Tot
    COMMON /INT4DB/ Dbsfg(MAXWELLS,45), Idefault(5), Iu(MAXWELLS,4), Nwlls,  &
       Totwell, Tot(MAXWELLS)
    CHARACTER Wllnms*80, Address*40, Lat*40, Formation*17
    COMMON /CHAR1 / Wllnms(MAXWELLS), Address(MAXWELLS,5), Lat(MAXWELLS), Formation(MAXWELLS)
    INTEGER Icase, Iw1, Iw2, Ir, Iex1, Io1, Iscr2
    COMMON /FUNITS/ Icase, Iw1, Iw2, Ir, Iex1, Io1, Iscr2
  
    !
    EXTERNAL LENS, UPCS
    INTRINSIC CHAR, ICHAR
    !
    DATA words/'Temperature     ', 'pH              ',  &
       'Dissolved Oxygen', 'Alkalinity      ', 'Tritium         ',  &
       'H2S as S        ', 'Calcium         ', 'Eh              ',  &
       'Magnesium       ', 'Sodium          ', 'Potassium       ',  &
       'Chloride        ', 'Sulfate         ', 'Fluoride        ',  &
       'Silica          ', 'Bromide         ', 'Boron           ',  &
       'Barium          ', 'Lithium         ', 'Strontium       ',  &
       'Iron            ', 'Manganese       ', 'Nitrate         ',  &
       'Ammonium        ', 'Phosphate       ', 'DOC             ',  &
       'Sp. Cond.       ', 'Density         ', 'Delta C-13 TDIC ',  &
       'Carbon 14 TDIC  ', 'Delta S-34 (SO4)', 'Delta S-34 (H2S)',  &
       'Delta Deuterium ', 'Delta O-18      ', 'CH4 (aq)        ',  &
       'Sr 87/86        ', 'Aluminum        ', 'N2 (aq)         ',  &
       'N-15 of N2 (aq) ', 'N-15 of Nitrate ', 'N-15 of Ammonium',  &
       'Depth           ', 'Casing          ', 'Elevation       ',  &
       'RS of DOC       '/
    character*2 location(45)
    integer location_num(45)
    !!
    TYPE (VARIANT) wnSafeArray  
    TYPE (VARIANT) flagsSafeArray  
    TYPE (VARIANT) val  
    TYPE(sa_bounds), DIMENSION(2) :: ab
    INTEGER iu_dup(MAXWELLS,4)
    CHARACTER*80 wllnms_dup(MAXWELLS)
    INTEGER*4, DIMENSION(2) :: indices
    INTEGER*4 lBound
    INTEGER*4 uBound

    data location/' G', ' H', &
	    'AD', ' P', 'AO', &
	    'AE', ' J', ' I', &
	    ' K', ' L', ' M', &
	    ' N', ' O', ' T', &
	    ' U', ' V', ' W', &
	    ' X', ' Y', ' Z', &
	    ' Q', ' R', 'AA', &
	    'AB', 'AC', 'AH', &
	    'AV', 'AU', 'AJ', &
	    'AK', 'AL', 'AM', &
	    'AN', 'AP', 'AG', &
	    'AQ', ' S', 'AF', &
	    'AR', 'AS', 'AT', &
	    'BB', 'BC', 'BD', &
	    'AI'/
    data location_num/7, 8, &  !  G,  H
        30, 16, 41, &          ! AD,  P, AO
        31, 10, 9,  &          ! AE,  J,  I
        11, 12, 13, &          !  K,  L,  M
        14, 15, 20, &          !  N,  O,  T
        21, 22, 23, &          !  U,  V,  W
        24, 25, 26, &          !  X,  Y,  Z
        17, 18, 27, &          !  Q,  R, AA
        28, 29, 34, &          ! AB, AC, AH
        48, 47, 36, &          ! AV, AU, AJ
        37, 38, 39, &          ! AK, AL, AM
        40, 42, 33, &          ! AN, AP, AG
        43, 19, 32, &          ! AQ,  S, AF
        44, 45, 46, &          ! AR, AS, AT
        54, 55, 56, &          ! BB, BC, BD
        35/                    ! AI

    WRITE (*,*) 'Reading Excel ...'
 
    !! calculate range
    write(string, "(i5)") MAXWELLS + 8
    do i = 1, 4
    if (string(1:1) .eq. ' ') string = string(2:5)
    enddo
    string = "BI"//string

    !! read data 
    call set_range("A8", string)
    wnSafeArray = Range_GetValue(range)  

    n = 1
    do i = 1, MAXWELLS 
       indices(1) = i;
       
       !! save well name B, column 2, cycle if empty
        indices(2) = 2;
        status = SafeArrayGetElement(wnSafeArray%VU%PTR_VAL, indices(1), LOC(val))
        if (val%VT == VT_BSTR) then
            status = ConvertBSTRToString(val%VU%PTR_VAL, string)
            wllnms(n)(5:80) = string
        else
            cycle
        endif
            
        !! Well num  A, column 1
        indices(2) = 1;
        tot(n) = n
        status = SafeArrayGetElement(wnSafeArray%VU%PTR_VAL, indices(1), LOC(val))
        if (val%VT == VT_R8) then
            tot(n) = val%VU%DOUBLE_VAL
        endif  

        !! save flags  C-F, columns 3-6
        do k=3,6
            indices(2) = k;
            status = SafeArrayGetElement(wnSafeArray%VU%PTR_VAL, indices(1), LOC(val))
            if (val%VT == VT_R8) then
                iu(n, k - 2) = val%VU%DOUBLE_VAL
            endif    
        enddo

        !! save data values, columns defined in location_num
        do j = 1, 45
            indices(2) = location_num(j);
            status = SafeArrayGetElement(wnSafeArray%VU%PTR_VAL, indices(1), LOC(val))
            if (val%VT == VT_R8) then
                dbdata(n,j) = val%VU%DOUBLE_VAL
                dbsfg(n, j) = 0
            else
                dbdata(n,j) = 0
                dbsfg(n, j) = -1
            endif
        enddo   
        
        !! save lat/lon values
        indices(2) = 52;   ! AZ
        status = SafeArrayGetElement(wnSafeArray%VU%PTR_VAL, indices(1), LOC(val))
        if (val%VT == VT_R8) then
            write(lat(n),"(G)") val%VU%DOUBLE_VAL
        else if (val%VT == VT_BSTR) then
            status = ConvertBSTRToString(val%VU%PTR_VAL, string)
            lat(n) = string
        endif        

		!       Address
        indices(2) = 57;   ! BE
        status = SafeArrayGetElement(wnSafeArray%VU%PTR_VAL, indices(1), LOC(val))
        if (val%VT == VT_R8) then
            write(address(n, 1),"(G)") val%VU%DOUBLE_VAL
        else if (val%VT == VT_BSTR) then
            status = ConvertBSTRToString(val%VU%PTR_VAL, string)
            address(n, 1) = string
        endif
        
        indices(2) = 58;   ! BF
        status = SafeArrayGetElement(wnSafeArray%VU%PTR_VAL, indices(1), LOC(val))
        if (val%VT == VT_R8) then
            write(address(n, 2),"(G)") val%VU%DOUBLE_VAL
        else if (val%VT == VT_BSTR) then
            status = ConvertBSTRToString(val%VU%PTR_VAL, string)
            address(n, 2) = string
        endif
        
        indices(2) = 59;   ! BG
        status = SafeArrayGetElement(wnSafeArray%VU%PTR_VAL, indices(1), LOC(val))
        if (val%VT == VT_R8) then
            write(address(n, 3),"(G)") val%VU%DOUBLE_VAL
        else if (val%VT == VT_BSTR) then
            status = ConvertBSTRToString(val%VU%PTR_VAL, string)
            address(n, 3) = string
        endif
        
        indices(2) = 60;   ! BH
        status = SafeArrayGetElement(wnSafeArray%VU%PTR_VAL, indices(1), LOC(val))
        if (val%VT == VT_R8) then
            write(address(n, 4),"(G)") val%VU%DOUBLE_VAL
        else if (val%VT == VT_BSTR) then
            status = ConvertBSTRToString(val%VU%PTR_VAL, string)
            address(n, 4) = string
        endif 
        
        indices(2) = 61;   ! BI
        status = SafeArrayGetElement(wnSafeArray%VU%PTR_VAL, indices(1), LOC(val))
        if (val%VT == VT_R8) then
            write(address(n, 5),"(G)") val%VU%DOUBLE_VAL
        else if (val%VT == VT_BSTR) then
            status = ConvertBSTRToString(val%VU%PTR_VAL, string)
            address(n, 5) = string
        endif  
        n = n + 1       
    enddo
    Nwlls = n - 1
    return
END SUBROUTINE xl2db
!
!
!
SUBROUTINE XL2PHREEQC
    USE max_size
    USE ADOBJECTS
    use oleaut32
    use ifcom
    use filenames, only: root, path
    IMPLICIT NONE
    INTEGER*4 status
    character*256 string
    character*256 strings(4)
    CHARACTER*16 words(45)
    CHARACTER*1 UPCS, ans
    CHARACTER*80 line
    CHARACTER*20 frmt
    CHARACTER*10 piece
    CHARACTER*80 funame, char_linenum, cell_location
    INTEGER LENS, n, i, jcounter, k, j, kk, linenum
    !
    REAL Dbdata
    COMMON /DB    / Dbdata(MAXWELLS,45)
    INTEGER Dbsfg, Idefault, Iu, Nwlls, Totwell, Tot
    COMMON /INT4DB/ Dbsfg(MAXWELLS,45), Idefault(5), Iu(MAXWELLS,4), Nwlls,  &
       Totwell, Tot(MAXWELLS)
    CHARACTER Wllnms*80, Address*40, Lat*40, Formation*17
    COMMON /CHAR1 / Wllnms(MAXWELLS), Address(MAXWELLS,5), Lat(MAXWELLS), Formation(MAXWELLS)
    INTEGER Icase, Iw1, Iw2, Ir, Iex1, Io1, Iscr2
    COMMON /FUNITS/ Icase, Iw1, Iw2, Ir, Iex1, Io1, Iscr2
  
    !
    EXTERNAL LENS, UPCS
    INTRINSIC CHAR, ICHAR
    !
    DATA words/'Temperature     ', 'pH              ',  &
       'Dissolved Oxygen', 'Alkalinity      ', 'Tritium         ',  &
       'H2S as S        ', 'Calcium         ', 'Eh              ',  &
       'Magnesium       ', 'Sodium          ', 'Potassium       ',  &
       'Chloride        ', 'Sulfate         ', 'Fluoride        ',  &
       'Silica          ', 'Bromide         ', 'Boron           ',  &
       'Barium          ', 'Lithium         ', 'Strontium       ',  &
       'Iron            ', 'Manganese       ', 'Nitrate         ',  &
       'Ammonium        ', 'Phosphate       ', 'DOC             ',  &
       'Sp. Cond.       ', 'Density         ', 'Delta C-13 TDIC ',  &
       'Carbon 14 TDIC  ', 'Delta S-34 (SO4)', 'Delta S-34 (H2S)',  &
       'Delta Deuterium ', 'Delta O-18      ', 'CH4 (aq)        ',  &
       'Sr 87/86        ', 'Aluminum        ', 'N2 (aq)         ',  &
       'N-15 of N2 (aq) ', 'N-15 of Nitrate ', 'N-15 of Ammonium',  &
       'Depth           ', 'Casing          ', 'Elevation       ',  &
       'RS of DOC       '/
    CHARACTER*16 headings(45)
    data headings / &
	'Number', &
	'Description', &
	'Units', &
	'Redox', &
	'Temp', &
	'pH', &
	'pe', &
	'Ca', &
	'Mg', &
	'Na', &
	'K', &
	'Cl', &
	'S(6)', &
	'Alkalinity', &
	'C(4)', &
	'Fe', &
	'Mn', &
	'Al', &
	'F', &
	'Si', &
	'Br', &
	'B', &
	'Ba', &
	'Li', &
	'Sr', &
	'N(5)', &
	'N(-3)', &
	'P', &
	'O(0)', &
	'S(-2)', &
	'N(0)', &
	'C(-4)', &
	'13C', &
	'14C', &
	'34S(6)', &
	'34S(-2)', &
	'2H', &
	'3H', &
	'18O', &
	'87Sr', &
	'15N(0)', &
	'15N(5)', &
	'15N(-3)', &
	'15N(3)', &
	'Density'/
    CHARACTER*16 subheadings(45)
    data subheadings / &
	' ', &
	' ', &
	' ', &
	' ', &
	' ', &
	' ', &
	' ', &
	'as Ca', &
	'as Mg', &
	'as Na', &
	'as K', &
	'as Cl', &
	'as SO4', &
	'gfw 50.04289', &
	'gfw 50.04289', &
	'as Fe', &
	'as Mn', &
	'as Al', &
	'as F', &
	'as SiO2', &
	'as Br', &
	'as B', &
	'as Ba', &
	'as Li', &
	'as Sr', &
	'as N', &
	'as N', &
	'as P', &
	'as O', &
	'as S', &
	'as N', &
	'as CH4', &
	' ', &
	' ', &
	' ', &
	' ', &
	' ', &
	' ', &
	' ', &
	' ', &
	' ', &
	' ', &
	' ', &
	' ', &
	' '/
    TYPE (VARIANT) wnSafeArray  
    TYPE (VARIANT) flagsSafeArray  
    TYPE (VARIANT) val 
    integer fileno /10/, error_test, iunits, l
    INTEGER*4, DIMENSION(2) :: indices 
    character*1 tab
    double precision f, conv, farray(5)
    logical present(5), any_present
    
    WRITE (*,*) 'Converting Excel to PHREEQC ...'
    tab = char(9)
    !!
    string = trim(root)//".pqi"
    open (fileno,FILE=string,IOSTAT=error_test,STATUS='REPLACE')
    if (error_test .ne. 0) then
        write(*,*) "Could not open file: ", TRIM(path)//TRIM(string)
        stop 'File could not be opened'
    endif
        
 
    !! calculate range
    write(string, "(i5)") MAXWELLS + 8
    do i = 1, 4
    if (string(1:1) .eq. ' ') string = string(2:5)
    enddo
    string = "BI"//string

    !! read data 
    call set_range("A8", string)
    wnSafeArray = Range_GetValue(range)  
    
    !! write headings
    write(fileno,'("SOLUTION_SPREAD")')
    do i = 1,45
        write(fileno, '(a15,a1)', advance='NO') headings(i), tab
    enddo
    write(fileno,'(a)')
    do i = 1,45
        write(fileno, '(a15,a1)', advance='NO') subheadings(i), tab
    enddo
    write(fileno,'(a)')

    n = 1

    do i = 1, MAXWELLS 
       indices(1) = i;
       
       !! save well name B, column 2, cycle if empty
        indices(2) = 2;
        status = SafeArrayGetElement(wnSafeArray%VU%PTR_VAL, indices(1), LOC(val))
        if (val%VT == VT_BSTR) then
            status = ConvertBSTRToString(val%VU%PTR_VAL, string)
        else
            cycle
        endif

        !! Well num  A, column 1
        write(fileno, '(i15,a1)', advance='NO') n, tab
        
        !! Description
        do j = 1, len(string)
            if (string(j:j) .eq. "#") string(j:j) = " "
        enddo
        write(fileno, '(A,a1)', advance='NO') trim(string), tab 

        !! Units
        indices(2) = 3;
        status = SafeArrayGetElement(wnSafeArray%VU%PTR_VAL, indices(1), LOC(val))
        j = 0
        if (val%VT == VT_R8) then
            j = val%VU%DOUBLE_VAL
        endif
        iunits = j
        if (j .eq. 0) write(fileno, '(A15,a1)', advance='NO') 'mmol/kgw', tab 
        if (j .eq. 1) then
            write(*,*) 'Phreeqc does not accept units of meq/L'
            stop
        endif        
        if (j .eq. 2) write(fileno, '(A15,a1)', advance='NO') 'mg/l', tab         
        if (j .eq. 3) write(fileno, '(A15,a1)', advance='NO') 'ppm', tab        
        if (j .eq. 4) write(fileno, '(A15,a1)', advance='NO') 'mmol/kgw', tab 
        
        !! redox
        indices(2) = 4;
        status = SafeArrayGetElement(wnSafeArray%VU%PTR_VAL, indices(1), LOC(val))
        j = 0
        if (val%VT == VT_R8) then
            j = val%VU%DOUBLE_VAL
        endif
        if (j .eq. 0) write(fileno, '("pe",a1)', advance='NO') tab 
        if (j .eq. 1) write(fileno, '("pe",a1)', advance='NO') tab   
        if (j .eq. 2) write(fileno, '("O(0)/O(-2)",a1)', advance='NO') tab 
        if (j .eq. 3) write(fileno, '("O(0)/O(-2)",a1)', advance='NO') tab  
        if (j .eq. 4) write(fileno, '("S(6)/S(-2)",a1)', advance='NO') tab  
            
        !! Temp
        indices(2) = 7;
        status = SafeArrayGetElement(wnSafeArray%VU%PTR_VAL, indices(1), LOC(val))
        if (val%VT == VT_R8) then
            f = val%VU%DOUBLE_VAL
            write(fileno, '(f15.3,a1)', advance='NO') f, tab
        else
            write(fileno, '(A15,a1)', advance='NO') " ", tab
        endif
        
        !! pH
        indices(2) = 8;
        status = SafeArrayGetElement(wnSafeArray%VU%PTR_VAL, indices(1), LOC(val))
        if (val%VT == VT_R8) then
            f = val%VU%DOUBLE_VAL
            write(fileno, '(f15.3,a1)', advance='NO') f, tab
        else
            write(fileno, '(A15,a1)', advance='NO') " ", tab
        endif
        
        !! pe
        indices(2) = 9;
        status = SafeArrayGetElement(wnSafeArray%VU%PTR_VAL, indices(1), LOC(val))
        if (val%VT == VT_R8) then
            f = val%VU%DOUBLE_VAL/.059
            write(fileno, '(f15.3,a1)', advance='NO') f, tab
        else
            write(fileno, '(A15,a1)', advance='NO') " ", tab
        endif
        
        !! Ca-SO4
        do j = 10, 15
            indices(2) = j;
            status = SafeArrayGetElement(wnSafeArray%VU%PTR_VAL, indices(1), LOC(val))
            if (val%VT == VT_R8) then
                f = val%VU%DOUBLE_VAL
                write(fileno, '(f15.3,a1)', advance='NO') f, tab
            else
                write(fileno, '(A15,a1)', advance='NO') " ", tab
            endif
        enddo 
        
        !! Alkalinity and TDIC
        indices(2) = 5;
        j = 0
        status = SafeArrayGetElement(wnSafeArray%VU%PTR_VAL, indices(1), LOC(val))         
        if (val%VT == VT_R8) then
            j = val%VU%DOUBLE_VAL       
        endif
        
        !! j is alkalinity/tdic flag
        !! iunits is units flag
        
        indices(2) = 16;
        status = SafeArrayGetElement(wnSafeArray%VU%PTR_VAL, indices(1), LOC(val))
        if (val%VT == VT_R8) then
            f = val%VU%DOUBLE_VAL
            conv = 1.0
            if (iunits .eq. 2 .or. iunits .eq. 3) then
                if (j .lt. 3) then
                    conv = 50.04289 / 61.0173
                endif
            endif
            if (j .ne. 2) then
                !! Alkalinity defined, TDIC not defined
                write(fileno, '(f15.3,a1)', advance='NO') f * conv, tab           
                write(fileno, '(A15,a1)', advance='NO') " ", tab
            else
                !! Alkalinity not defined, TDIC defined
                write(fileno, '(A15,a1)', advance='NO') " ", tab
                write(fileno, '(f15.3,a1)', advance='NO') f * conv, tab           
            endif
        else
            write(fileno, '(A15,a1)', advance='NO') " ", tab           
            write(fileno, '(A15,a1)', advance='NO') " ", tab
        endif

        !! Fe - P
        do j = 17, 29
            indices(2) = j;
            status = SafeArrayGetElement(wnSafeArray%VU%PTR_VAL, indices(1), LOC(val))
            if (val%VT == VT_R8) then
                f = val%VU%DOUBLE_VAL
                write(fileno, '(f15.3,a1)', advance='NO') f, tab
            else
                write(fileno, '(A15,a1)', advance='NO') " ", tab
            endif
        enddo 
        
        !! O2, no conversion necessary for mass, factor of 2 for moles
        indices(2) = 30;
        status = SafeArrayGetElement(wnSafeArray%VU%PTR_VAL, indices(1), LOC(val))
        conv = 1.0
        if (iunits .lt. 2 .or. iunits .gt. 3) conv = 2
        if (val%VT == VT_R8) then
            f = val%VU%DOUBLE_VAL
            write(fileno, '(f15.3,a1)', advance='NO') conv*f, tab
        else
            write(fileno, '(A15,a1)', advance='NO') " ", tab
        endif      
    
        !! H2S to CH4
        do j = 31, 33
            indices(2) = j;
            status = SafeArrayGetElement(wnSafeArray%VU%PTR_VAL, indices(1), LOC(val))
            if (val%VT == VT_R8) then
                f = val%VU%DOUBLE_VAL
                write(fileno, '(f15.3,a1)', advance='NO') f, tab
            else
                write(fileno, '(A15,a1)', advance='NO') " ", tab
            endif
        enddo 
        
        !!
        !! 13C & 14C
        do j = 36, 37
            indices(2) = j;
            status = SafeArrayGetElement(wnSafeArray%VU%PTR_VAL, indices(1), LOC(val))
            if (val%VT == VT_R8) then
                f = val%VU%DOUBLE_VAL
                write(fileno, '(f15.3,a1)', advance='NO') f, tab
            else
                write(fileno, '(A15,a1)', advance='NO') " ", tab
            endif
        enddo 
            
        !! 34S(6) and 34S(-2)
        any_present = .FALSE.
        do j = 38,  39
            indices(2) = j;
            l = j - 37
            present(l) = .FALSE.
            status = SafeArrayGetElement(wnSafeArray%VU%PTR_VAL, indices(1), LOC(val))
            if (val%VT == VT_R8) then
                farray(l) = val%VU%DOUBLE_VAL
                f = farray(l)
                present(l) = .TRUE.
                any_present = .TRUE.
            endif
        enddo 
        if (any_present .eq. .FALSE.) then
            write(fileno, '(A15,a1)', advance='NO') " ", tab
            write(fileno, '(A15,a1)', advance='NO') " ", tab
        else 
            do j = 1, 2 
                if (present(j)) then
                    write(fileno, '(f15.3,a1)', advance='NO') farray(j), tab
                else
                    write(fileno, '(f15.3,a1)', advance='NO') f, tab
                endif 
            enddo
        endif        
        
        !! 2H through 87Sr
        do j = 40, 43
            indices(2) = j;
            status = SafeArrayGetElement(wnSafeArray%VU%PTR_VAL, indices(1), LOC(val))
            if (val%VT == VT_R8) then
                f = val%VU%DOUBLE_VAL
                write(fileno, '(f15.3,a1)', advance='NO') f, tab
            else
                write(fileno, '(A15,a1)', advance='NO') " ", tab
            endif
        enddo 

        !! 15N for N(0), N(5), N(-3), N(3)
        any_present = .FALSE.
        present(4) = .FALSE.
        do j = 44, 46
            indices(2) = j;
            l = j - 43
            present(l) = .FALSE.
            status = SafeArrayGetElement(wnSafeArray%VU%PTR_VAL, indices(1), LOC(val))
            if (val%VT == VT_R8) then
                farray(l) = val%VU%DOUBLE_VAL
                f = farray(l)
                present(l) = .TRUE.
                any_present = .TRUE.
            endif
        enddo 
        if (any_present .eq. .FALSE.) then
            write(fileno, '(A15,a1)', advance='NO') " ", tab
            write(fileno, '(A15,a1)', advance='NO') " ", tab
            write(fileno, '(A15,a1)', advance='NO') " ", tab
            write(fileno, '(A15,a1)', advance='NO') " ", tab
        else 
            do j = 1, 4 
                if (present(j)) then
                    write(fileno, '(f15.3,a1)', advance='NO') farray(j), tab
                else
                    write(fileno, '(f15.3,a1)', advance='NO') f, tab
                endif 
            enddo
        endif  
        
        !! Density
        indices(2) = 47;
        status = SafeArrayGetElement(wnSafeArray%VU%PTR_VAL, indices(1), LOC(val))
        if (val%VT == VT_R8) then
            f = val%VU%DOUBLE_VAL
            write(fileno, '(f15.3,a1)', advance='NO') f, tab
        else
            write(fileno, '(A15,a1)', advance='NO') " ", tab
        endif
        
        !! End of line
        write(fileno,'(a)')      
   
        !! increment n
        n = n + 1       
    enddo
    close(fileno)
    
    return
END SUBROUTINE xl2phreeqc
!
!
!
subroutine doCreate(string)

	  USE IFWIN
	  USE ADOBJECTS

character*(*) string

type (T_OPENFILENAME)       of
character*256               buffer
character*256               buffer1
character*56                buffer2
character*56                buffer3
character*56                buffer4
character*256               szFileTitle

type (T_STARTUPINFO)            sui
type (T_PROCESS_INFORMATION)    pi

integer*4           ret

logical(4)          bret
integer*4           l

szFileTitle = ""C
buffer = szFileTitle



!    /* set up the STARTUPINFO structure,
!     *  then call CreateProcess to try and start the new exe.
!     */
sui%cb             = 68 ! SIZESTARTUPINFO  ! 68 ( sizeof(StartUpInfo)
sui%lpReserved       = 0
sui%lpDesktop        = NULL
sui%lpTitle          = NULL
sui%dwX              = 0
sui%dwY              = 0
sui%dwXSize          = 0
sui%dwYSize          = 0
sui%dwXCountChars    = 0
sui%dwYCountChars    = 0
sui%dwFillAttribute  = 0
sui%dwFlags          = 0
sui%wShowWindow      = 0
sui%cbReserved2      = 0
sui%lpReserved2      = 0

buffer = string
buffer(lens(buffer) + 1: lens(buffer) + 2) = szFileTitle(1:2)
l = 0
bret = CreateProcess (                              &
					 NULL_CHARACTER,                &
					 buffer,        &
					 NULL_SECURITY_ATTRIBUTES,      &
					 NULL_SECURITY_ATTRIBUTES,      &
					 l,                       &
					 DETACHED_PROCESS,              &
					 NULL,                          &
					 NULL_CHARACTER,                &
					 sui, &
					 pi)

return

end

